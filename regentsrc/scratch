

  var dumpiter : int32 = 0
  var token : int32 = 0
  var TS_start = c.legion_get_current_time_in_micros()
  var Tf : double = 0
  var Tsim : double = 0
  while Tsim < Tf do
    wait_for(token)
    var iter_start = c.legion_get_current_time_in_micros()


    -- Iterate for maxiter timesteps
    var iter : int32 = 0
    __forbid(__parallel)
    for iter = 1, maxiter+1 do
      __fence(__execution, __block)
      c.printf("Current Realization : %d, Current Iteration : %d\n", rel, iter)
      -- Repartition based on Color Field
      var particles = partition(r_particles.b, p_colors)

      -- Collisions
      __demand(__parallel)
      for color in particles.colors do
        Collision(particles[color], p_rng[color], s, Ne, dt, Vc)
      end

      -- Advect
      __demand(__parallel)
      for color in particles.colors do
        Advect(particles[color], p_rng[color], L, w, dt)
      end

      -- Sort into Boxes
      __demand(__parallel)
      for color in particles.colors do
        Sort(particles[color], boxes, L)
      end

      if (iter%(25)) == 0 and out then
        grid += 1
        token += Dump(r_particles, grid)
      end
      if (iter%(25)) == 0 and out then
        wait_for(token)
        c.printf("Dumped Grid %d\n", grid)
      end

      if iter == maxiter and rel < reals then
        var sd : bool = (rel == start) --seed
        __demand(__parallel)
        for color in p_colors do
          token += initialize(p_particles[color],p_rng[color], color, boxes, TL, TR, pL, pR, L, w, sd)
        end
      end
    end --this one ends the 'while T < endtime' loop


    wait_for(token)
    var rel_end = c.legion_get_current_time_in_micros()
    c.printf("Realization %d took %.6f sec\n", rel, (rel_end-rel_start)*1e-6)
  end

  var TS_end = c.legion_get_current_time_in_micros()

  wait_for(token)
  c.printf("Done\n")
  c.printf("Total time: %.6f sec.\n", (TS_end - TS_start) * 1e-6)

  --Dump(r_particles)
